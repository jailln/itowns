<html>
    <head>
        <title>Itowns - Globe + Multipolygon Geojson</title>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="css/example.css">
        <link rel="stylesheet" type="text/css" href="css/LoadingScreen.css">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
    </head>
    <body>
        <div id="viewerDiv" class="viewer"></div>
        <script src="js/GUI/GuiTools.js"></script>
        <script src="../dist/itowns.js"></script>
        <script src="../dist/debug.js"></script>
        <script type="text/javascript">var THREE=itowns.THREE;</script>
        <script src="https://unpkg.com/three@0.129.0/examples/js/loaders/GLTFLoader.js"></script>

        <script type="text/javascript">
            // Define initial camera position
            var positionOnGlobe = { longitude: -0.57918, latitude: 44.837789, altitude: 3000 };
            var placement = {
                coord: new itowns.Coordinates('EPSG:4326', -0.57918, 44.837789),
                range: 3000,
                tilt: 45,
            };
            
            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            var viewerDiv = document.getElementById('viewerDiv');

            // Instanciate iTowns GlobeView*
            var view = new itowns.GlobeView(viewerDiv, placement);
            var menuGlobe = new GuiTools('menuDiv', view);

            var ambLight = new itowns.THREE.AmbientLight(0xffffff, 0.2);
            view.scene.add( ambLight );

            // Add one imagery layer to the scene
           /*itowns.Fetcher.json('./layers/JSONLayers/Ortho.json').then(function _(config) {
                config.source = new itowns.WMTSSource(config.source);
                var layer = new itowns.ColorLayer('Ortho', config);
                view.addLayer(layer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
            });
    */
            itowns.Fetcher.json('./layers/JSONLayers/Dark.json').then(function _(config) {
                config.source = new itowns.TMSSource(config.source);
                var layer = new itowns.ColorLayer('Ortho', config);
                view.addLayer(layer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
            });


            /* Arbres */
    const trunkRadius = 5;
    const trunkHeight = 20;
    const topHeight = 10;

    function makeTree() {
        const root = new THREE.Object3D();

        // tronc
        const geometry = new THREE.CylinderGeometry( trunkRadius, trunkRadius, trunkHeight, 32 );
        const material = new THREE.MeshPhongMaterial( {color: 0x8B4513} );
        const tronc = new THREE.Mesh( geometry, material );
        tronc.rotateX(Math.PI / 2);
        // hack temporaire
        tronc.position.z = 280 ;
        tronc.updateMatrix();
        root.add(tronc);

        // canopée
        const geometryCanop = new THREE.SphereGeometry( topHeight, topHeight, 10 );
        const materialCanop = new THREE.MeshPhongMaterial( { color: 0x00aa00 } );
        const top = new THREE.Mesh( geometryCanop, materialCanop );
        top.position.z = trunkHeight - (topHeight / 3) + 280;
        top.updateMatrix();
        root.add(top);

  return root;
}
 
function makeRectangle() {
    const root = new THREE.Object3D();

    // poteau fake
    const geometry = new THREE.CylinderGeometry( trunkRadius, trunkRadius, trunkHeight, 32 );
    const material = new THREE.MeshPhongMaterial( {color: 0xf7c015} );
    const tronc = new THREE.Mesh( geometry, material );
    // hack temporaire
    tronc.position.z = 20;
    tronc.rotateX(Math.PI / 2);
    tronc.updateMatrix();
    root.add(tronc);

    return root;
}


// Load a gltf model
    // Instantiate a loader
    const loader = new THREE.GLTFLoader();
    
var meshes = [];
var color = new itowns.THREE.Color();
            var tile;
            function colorBuildings(properties) {
                
                if(properties.nature != undefined) {
                    switch (properties.nature) {
                        case "Bâtiment sportif":
                            return color.set(0xFDD835);
                            break;
                        case "Bâtiment commercial":
                            return color.set(0xE53935);
                            break;
                        case "Bâtiment religieux":
                            return color.set(0xF48FB1);
                            break;
                        case "Eglise":
                            return color.set(0xF48FB1);
                            break;
                        case "Gare":
                            return color.set(0x1565C0);
                            break;
                        case "Bâtiment industriel":
                            return color.set(0x3F51B5);
                            break;
                        case "Mairie":
                            return color.set(0xE91E63);
                        break;
                        case "Serre":
                            return color.set(0x4CAF50);
                        break;
                    }
                }
                else {
                    if(properties.origin_bat != undefined && properties.origin_bat == "Cadastre") {
                        return color.set(0xfef1eb);
                    }
                    else {
                       return color.set(0xEF1A1A);
                    }
                    
                }

            }

            function altitudeBuildings(properties) {
                return 0 ; //properties.z_min - properties.hauteur;
            }

            function extrudeBuildings(properties) {
                return properties.hauteur;
            }

            function acceptFeature(properties) {
                return !!properties.hauteur;
            }

            scaler = function update() {
                var i;
                var mesh;
                if (meshes.length) {
                    view.notifyChange(view.camera.camera3D, true);
                }
                for (i = 0; i < meshes.length; i++) {
                    mesh = meshes[i];
                    if (mesh) {
                        mesh.scale.z = Math.min(
                            1.0, mesh.scale.z + 0.1);
                        mesh.updateMatrixWorld(true);
                    }
                }
                meshes = meshes.filter(function filter(m) { return m.scale.z < 1; });
            };

            view.addFrameRequester(itowns.MAIN_LOOP_EVENTS.BEFORE_RENDER, scaler);
  


            var wfsBuildingSource = new itowns.WFSSource({
                url: 'https://wxs.ign.fr/3ht7xcw6f7nciopo16etuqp2/geoportail/wfs?',
                version: '2.0.0',
                typeName: 'BDTOPO_BDD_WLD_WGS84G:bati_remarquable,BDTOPO_BDD_WLD_WGS84G:bati_indifferencie,BDTOPO_BDD_WLD_WGS84G:bati_industriel',
                crs: 'EPSG:4326',
                ipr: 'IGN',
                format: 'application/json',
                extent: {
                    west: -0.85,
                    east: -0.1,
                    south: 44.807789,
                    north: 44.877789,
                },
            });

            var wfsBuildingLayer = new itowns.FeatureGeometryLayer('WFS Building',{
                batchId: function (property, featureId) { return featureId; },
                onMeshCreated: function scaleZ(mesh) {
                    mesh.children.forEach(c => {
                        c.scale.z = 0.01;
                        meshes.push(c);
                    })
                },
                filter: acceptFeature,
                source: wfsBuildingSource,
                zoom: { min: 14 },

                style: new itowns.Style({
                    fill: {
                        color: colorBuildings,
                        base_altitude: altitudeBuildings,
                        extrusion_height: extrudeBuildings,
                    }
                })
            });
            
            // view.addLayer(wfsBuildingLayer);

 // ---------- DISPLAY VECTOR TILED BUILDING DATA AS 3D MESHES : ----------

            // Define the source of the building data : those are vector tiled data from the geoportail.
            const buildingsSource = new itowns.VectorTilesSource({
                style: 'https://wxs.ign.fr/essentiels/static/vectorTiles/styles/PLAN.IGN/standard.json',
                // We only want to display buildings related data.
                filter: (layer) => {
                    return layer['source-layer'].includes('bati_surf')
                        && layer.paint["fill-color"];
                },
            });

            // Create a FeatureGeometryLayer to support building data.
            var buildingsLayer = new itowns.FeatureGeometryLayer('VTBuilding',{
                source: buildingsSource,
                zoom: { min: 15 },
                accurate: false,
                style: new itowns.Style({
                    fill: {
                        base_altitude: (p) => p.alti_sol || 0,
                        extrusion_height: (p) => p.hauteur || 0,
                    }
                })
            });

            // Add the FeatureGeometryLayer to the scene and to the debug menu.
            view.addLayer(buildingsLayer).then((layer) => {
                const gui = debug.GeometryDebug.createGeometryDebugUI(debugMenu.gui, view, layer);
                debug.GeometryDebug.addWireFrameCheckbox(gui, view, layer);
            })



            // Eau 

            var eauSource = new itowns.FileSource({
                url: './eaux bordeaux.geojson',
                crs: 'EPSG:4326',
                fetcher: itowns.Fetcher.json,
                parser: itowns.GeoJsonParser.parse,
            });

            var eauLayer = new itowns.FeatureGeometryLayer('eau', {
                name: 'eau',
                source: eauSource,
                zoom: { min: 9 },

                style: new itowns.Style({
                    fill: { color: color.set(0x7BD5F5), opacity: 0.5, base_altitude: 2 },
                    stroke: { color: 'blue', base_altitude: 5},
                }),
            });

             view.addLayer(eauLayer);

// Electriques

loader.load(
    // resource URL
    // 'http://localhost:8080/data/lampadaire/scene.gltf',
    //  'http://localhost:8080/data/giant_low_poly_tree/scene.gltf',
     'http://localhost:8080/data/tree_low-poly_3d_model/scene.gltf',
    // called when the resource is loaded
    (gltf) => {
        // styleModel3D.model.object = gltf.scene; 
        //view.scene.add(gltf.scene);
        //mergeAll(gltf.scene);
        console.log(gltf.scene);  
        gltf.scene.children[0].rotateZ(Math.PI);
        gltf.scene.children[0].scale.set(0.02, 0.02, 0.02);
  
        gltf.scene.updateMatrix();
        gltf.scene.updateMatrixWorld();
        
        
    var styleModel3D = new itowns.Style({
            // model: { object:  gltf.scene }
             model : { object : makeRectangle()}
    });

    var lightSource = new itowns.FileSource({
        url: './layers/JSONLayers/point lumineux bordeaux 2019.geojson',
        crs: 'EPSG:4326',
        fetcher: itowns.Fetcher.json,
        parser: itowns.GeoJsonParser.parse,
    });

    var lightLayer = new itowns.FeatureGeometryLayer('luminaire', {
        name: 'luminaire',
        source: lightSource,
        zoom: { min: 7, max : 21},
        style:  styleModel3D
    });

    view.addLayer(lightLayer);


    },
    // called while loading is progressing
    (xhr) => {
        console.log(`${xhr.loaded / xhr.total * 100}% loaded`);
    },
    // called when loading has errors
    (error) => {
        console.log('An error happened :');
        console.log(error);
    },
); 

// Load a glTF resource

loader.load(
    // resource URL
    // 'http://localhost:8080/data/lampadaire/scene.gltf',
    // 'http://localhost:8080/data/giant_low_poly_tree/scene.gltf',
     'http://localhost:8080/data/tree_low-poly_3d_model/scene.gltf',
    // called when the resource is loaded
    (gltf) => {

        console.log(gltf.scene);  
        // gltf.scene.rotateY(Math.PI );

        gltf.scene.updateMatrix();
        gltf.scene.updateMatrixWorld();
        
        
    var styleModel3D = new itowns.Style({
             // model: { object:  gltf.scene  }
              model : { object : makeTree() }
             // model : { object : makeRectangle()}
    });



    var arbreSource = new itowns.FileSource({
        url: './layers/JSONLayers/trees.geojson',
        // url: './layers/JSONLayers/point lumineux bordeaux 2019.geojson',
        crs: 'EPSG:4326',
        fetcher: itowns.Fetcher.json,
        parser: itowns.GeoJsonParser.parse,
    });

    var arbreLayer = new itowns.FeatureGeometryLayer('arbre', {
        name: 'arbre',
        source: arbreSource,
        zoom: { min: 7, max : 21},
        style:  styleModel3D
    });

    view.addLayer(arbreLayer);


    },
    // called while loading is progressing
    (xhr) => {
        console.log(`${xhr.loaded / xhr.total * 100}% loaded`);
    },
    // called when loading has errors
    (error) => {
        console.log('An error happened :');
        console.log(error);
    },
); 

/*
    var layer = view.tileLayer;
    layer.dynamicOpacity = true;
    layer.disableSkirt = true;
    // view.removeLayer(view.atmosphereLayer.id);
    view.scene.background = new THREE.Color(0x000000);
        */

    debug.createTileDebugUI(menuGlobe.gui, view);


        </script>
    </body>

</html>