<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Tutorial : Vector visualization - As 3D objects</title>

    <script src="../scripts/prettify/prettify.js"> </script>
    <script src="../scripts/prettify/lang-css.js"> </script>
    <link type="text/css" rel="stylesheet" href="../styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="../styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="../styles/itowns.css">
</head>

<body>

<section>

<header>
    <h1>Tutorial : Vector visualization - As 3D objects</h1>
</header>

<article>
    <p>The goal of this tutorial is to give a brief example on how to use iTowns to visualize some vector data as 3D objects.
These vector data shall represent buildings and be displayed on the <code>PlanarView</code> we created in the
<a href="Raster-data-CC46.html">CC46 tutorial</a>.</p>
<h2>Preparing the field</h2>
<p>To display our buildings, we are going to use the data created in the <a href="Raster-data-CC46.html">CC46 tutorial</a>.
As we are trying to display some buildings, let's move closer to the ground to see something and let's change the camera
initial rotation.
For this, we need to change the starting position to something more appropriate.</p>
<pre class="prettyprint source lang-html"><code>&lt;!DOCTYPE html>
&lt;html>
    &lt;head>
        &lt;meta charset=&quot;UTF-8&quot;>
        &lt;title>Vector data in 3D&lt;/title>
        &lt;style>
            html { height: 100%; }
            body { margin: 0; overflow: hidden; height: 100%; }
            #viewerDiv { margin: auto; height: 100%; width: 100%; padding: 0; }
            canvas { display: block }
        &lt;/style>
     &lt;/head>
     &lt;body>
        &lt;div id=&quot;viewerDiv&quot;>&lt;/div>
        &lt;script src=&quot;js/itowns.js&quot;>&lt;/script>
        &lt;script type=&quot;text/javascript&quot;>

            // Retrieve the view container
            const viewerDiv = document.getElementById('viewerDiv');

            // Define the view geographic extent
            itowns.proj4.defs(
                'EPSG:3946',
                '+proj=lcc +lat_1=45.25 +lat_2=46.75 +lat_0=46 +lon_0=3 +x_0=1700000 +y_0=5200000 +ellps=GRS80 ' +
                '+towgs84=0,0,0,0,0,0,0 +units=m +no_defs',
            );
            const viewExtent = new itowns.Extent(
                'EPSG:3946',
                1837816.94334, 1847692.32501,
                5170036.4587, 5178412.82698,
            );

            // Define the camera initial placement
            const placement = {
                coord: new itowns.Coordinates('EPSG:3946', 1840839, 5172718, 0),
                tilt: 30,
                heading: 45,
                range: 1800,
            };

            // Create the planar view
            const view = new itowns.PlanarView(viewerDiv, viewExtent, {
                placement: placement,
            });

            // Define the source of the ortho-images
            const sourceOrtho = new itowns.WMSSource({
                url: 'https://download.data.grandlyon.com/wms/grandlyon',
                name: 'Ortho2009_vue_ensemble_16cm_CC46',
                format: 'image/jpeg',
                crs: 'EPSG:3946',
                extent: viewExtent,
            });
            // Create the ortho-images ColorLayer and add it to the view
            const layerOrtho = new itowns.ColorLayer('Ortho', { source: sourceOrtho });
            view.addLayer(layerOrtho);

            // Define the source of the dem data
            const sourceDEM = new itowns.WMSSource({
                url: 'https://download.data.grandlyon.com/wms/grandlyon',
                name: 'MNT2018_Altitude_2m',
                format: 'image/jpeg',
                crs: 'EPSG:3946',
                extent: viewExtent,
            });
            // Create the dem ElevationLayer and add it to the view
            const layerDEM = new itowns.ElevationLayer('DEM', {
                source: sourceDEM,
                useColorTextureElevation: true,
                colorTextureElevationMinZ: 144,
                colorTextureElevationMaxZ: 622,
            });
            view.addLayer(layerDEM);
            
        &lt;/script>
     &lt;/body>
&lt;/html>
</code></pre>
<h2>Adding a GeometryLayer</h2>
<p>We want to create and add a layer containing geometries. The best candidate here
is <code><a onclick="window.parent.goTo('api/Layer/FeatureGeometryLayer.html','api/Layer/FeatureGeometryLayer')" title="FeatureGeometryLayer">FeatureGeometryLayer</a></code>, which is a pre-made type of <code><a onclick="window.parent.goTo('api/Layer/GeometryLayer.html','api/Layer/GeometryLayer')" title="GeometryLayer">GeometryLayer</a></code>
adapted to our use case. Reading the documentation, adding this type
of layer is similar to the other layers. So before declaring the layer, let's
instantiate the source.</p>
<pre class="prettyprint source lang-js"><code>const buildingsSource = new itowns.WFSSource({
    url: 'http://wxs.ign.fr/3ht7xcw6f7nciopo16etuqp2/geoportail/wfs?',
    typeName: 'BDTOPO_BDD_WLD_WGS84G:bati_indifferencie',
    crs: 'EPSG:4326',
});
</code></pre>
<p>With our source instantiated, we can create our <code>FeatureGeometryLayer</code>, giving it the usual <code>id</code> and <code>source</code> parameters :</p>
<pre class="prettyprint source lang-js"><code>const buildingsLayer = new itowns.FeatureGeometryLayer('Buildings', {
    source: buildingsSource,
    zoom: { min: 4 },
});

view.addLayer(buildingsLayer);
</code></pre>
<p>We also added a minimal <code>zoom</code> parameter to prevent our data from being displayed under a certain
zoom level at which we would be too far from the data to distinguish them.</p>
<p>Trying this code will result visually in the following.</p>
<p><img src="images/Vector-data-3d-1.png" alt="geometry_layer_without_altitude"></p>
<p>We can see the polygons fetched from the data source, each representing a building.
However, these polygons are not on the ground.
Indeed, they were placed after the 3D positions stored in the data, which in our case represent points on the roof of buildings.
So let's start modifying these polygons' altitude to place them on the ground !</p>
<h2>Placing the data on the ground</h2>
<p>To achieve the positioning relative to the elevation layer, we will need to add
a parameter to the <code>FeatureGeometryLayer</code>, which is its <code><a onclick="window.parent.goTo('api/Base/Style.html','api/Base/Style')" title="Style">Style</a></code>.
As mentioned in the <a href="Fundamentals.html">fundamentals</a> tutorial, we can modify the appearance and positioning of polygons thanks to the <code>fill</code> property of <code>Style</code>.
The altitude at which polygons are displayed can be modified using the <code>base_altitude</code> parameter, which we set as follows :</p>
<pre class="prettyprint source lang-js"><code>function setBuildingsAltitude(properties) {
    console.log(properties);
}

const buildingsSource = new itowns.WFSSource({
    url: 'http://wxs.ign.fr/3ht7xcw6f7nciopo16etuqp2/geoportail/wfs?',
    typeName: 'BDTOPO_BDD_WLD_WGS84G:bati_indifferencie',
    crs: 'EPSG:4326',
});

const buildingsLayer = new itowns.FeatureGeometryLayer('Buildings', {
    source: buildingsSource,
    zoom: { min: 4 },
    style: new itowns.Style({
        fill: {
            base_altitude: setBuildingsAltitude,
        }
    }),
});

view.addLayer(buildingsLayer);
</code></pre>
<p>If we take a look using <code>console.log(properties);</code> at what we have in the
<code>properties</code> object, we will get a lot of output. Our data being constituted of
multiple buildings, we get an output for each building. Looking closer to an
output, here is what we can obtain :</p>
<pre class="prettyprint source lang-js"><code>geometry_name: &quot;the_geom&quot;
hauteur: 9
id: &quot;bati_indifferencie.19138409&quot;
origin_bat: &quot;Cadastre&quot;
prec_alti: 5
prec_plani: 2.5
z_max: 83.7
z_min: 83.7
</code></pre>
<p>Reading the documentation of the database we are querying (<a href="http://professionnels.ign.fr/doc/DC_BDTOPO_3-0.pdf">section 9.1, page
84</a>, in French), we have an
explanation on each property. To help us place the data correctly, let's use the
<code>z_min</code> and the <code>hauteur</code> properties.
The first one corresponds to the altitude of the building roof, and the second one specifies its height.
We can therefore set the base altitude of our buildings by removing the value of <code>hauteur</code> to the value of <code>z_min</code> :</p>
<pre class="prettyprint source lang-js"><code>function setBuildingsAltitude(properties) {
    return properties.z_min - properties.hauteur;
}
</code></pre>
<p>Now we can't see completely our buildings. What can we do about that
? Let's give them volume !</p>
<p><img src="images/Vector-data-3d-2.png" alt="Still flat buildings on GeometryLayer"></p>
<h2>Extruding the data</h2>
<p>Like the altitude, the volume of buildings can be changed using the <code>extrusion_height</code>
parameter of the <code>Style.fill</code> property.</p>
<pre class="prettyprint source lang-js"><code>function setBuildingsExtrusion(properties) {
    return properties.hauteur;
}

const buildingsSource = new itowns.WFSSource({
    url: 'http://wxs.ign.fr/3ht7xcw6f7nciopo16etuqp2/geoportail/wfs?',
    typeName: 'BDTOPO_BDD_WLD_WGS84G:bati_indifferencie',
    crs: 'EPSG:4326',
});

const buildingsLayer = new itowns.FeatureGeometryLayer('Buildings', {
    source: buildingsSource,
    zoom: { min: 4 },
    style: new itowns.Style({
        fill: {
            base_altitude: setBuildingsAltitude,
            extrusion_height: setBuildingsExtrusion,
        }
    }),
});

view.addLayer(buildingsLayer);
</code></pre>
<p>The parameter <code>properties</code> of the <code>setBuildingsExtrusion</code> method is the same as in
<code>setBuildingsAltitude</code>. We noticed there is a <code>hauteur</code> (<code>height</code> in French) property that
we could use to set the height of the building. Moving around with this gives a
nice view of our buildings :</p>
<p><img src="images/Vector-data-3d-3.png" alt="Extruded buildings on GeometryLayer"></p>
<h2>Coloring the data</h2>
<p>We are not yet touching the color of the buildings. This results in every
building being randomly colored at each time. To solve this, as we did before,
we can add a <code>color</code> parameter to the <code>Style.fill</code> property.</p>
<pre class="prettyprint source lang-js"><code>function setBuildingsColor(properties) {
    return new itowns.THREE.Color(0xaaaaaa);
}

const buildingsSource = new itowns.WFSSource({
    url: 'http://wxs.ign.fr/3ht7xcw6f7nciopo16etuqp2/geoportail/wfs?',
    typeName: 'BDTOPO_BDD_WLD_WGS84G:bati_indifferencie',
    crs: 'EPSG:4326',
});

const buildingsLayer = new itowns.FeatureGeometryLayer('Buildings', {
    source: buildingsSource,
    zoom: { min: 4 },
    style: new itowns.Style({
        fill: {
            color: setBuildingsColor,
            base_altitude: setBuildingsAltitude,
            extrusion_height: setBuildingsExtrusion,
        },
    }),
});
view.addLayer(buildingsLayer);
</code></pre>
<p>For each building, a new color is created (using <code>THREE.Color</code>), and this results
in all buildings being colored in a light gray.</p>
<p><img src="images/Vector-data-3d-4.png" alt="Extruded and colored buildings on GeometryLayer"></p>
<h2>Position data with no altitude</h2>
<p>The buildings data we just displayed had some properties that allowed us to compute buildings base altitude.
However, if none of these properties are available, we can use iTowns <code>DEMUtils</code> to compute objects base altitude.</p>
<p>For example, let's display some bus lines data :</p>
<pre class="prettyprint source lang-js"><code>const busSource = new itowns.WFSSource({
    url: 'https://download.data.grandlyon.com/wfs/rdata?',
    typeName: 'tcl_sytral.tcllignebus',
    format: 'geojson',
    crs: 'EPSG:3946',
    version: '2.0.0',
});

const busLayer = new itowns.FeatureGeometryLayer('Bus', {
    source: busSource,
    zoom: { min: 4 },
    style: new itowns.Style({
        stroke: {
            width: 5,
        },
    }),
})
view.addLayer(busLayer);
</code></pre>
<p>What we do here is similar to what we did with buildings : we define the source of our data (<code><a onclick="window.parent.goTo('api/Source/WFSSource.html','api/Source/WFSSource')" title="WFSSource">WFSSource</a></code> here),
we create a <code><a onclick="window.parent.goTo('api/Layer/FeatureGeometryLayer.html','api/Layer/FeatureGeometryLayer')" title="FeatureGeometryLayer">FeatureGeometryLayer</a></code> to support our data and we add it to our <code><a onclick="window.parent.goTo('api/View/PlanarView.html','api/View/PlanarView')" title="PlanarView">PlanarView</a></code>.</p>
<p>We can then display data properties the same way we did for the buildings.</p>
<pre class="prettyprint source lang-js"><code>function setBusAltitude(properties) {
    console.log(properties);
}

const busLayer = new itowns.FeatureGeometryLayer('Bus', {
    source: busSource,
    zoom: { min: 4 },
    style: new itowns.Style({
        stroke: {
            width: 5,
            base_altitude: setBusAltitude,
        },
    }),
})
view.addLayer(busLayer);
</code></pre>
<p>We can see that no altitude information can be found in properties.
To set the altitude of our bus data, we are going to use a second optional parameter of the <code>setBusAltitude</code> method.
This parameter gives <code><a onclick="window.parent.goTo('api/Geographic/Coordinates.html','api/Geographic/Coordinates')" title="Coordinates">Coordinates</a></code> of points along the line.
With <code>DEMUtils</code>, we can compute the altitude at each of these coordinates :</p>
<pre class="prettyprint source lang-js"><code>function setBusAltitude(properties, coordinates) {
    if (coordinates) {
        return (itowns.DEMUtils.getElevationValueAt(view.tileLayer, contour) || 0) + 5
    }
    return 5;
}
</code></pre>
<p>We raise bus lines altitude a bit (hence the <code>+ 5</code>) so that lines appear above the ground, and not half burried.
Here is what we obtain :</p>
<p><img src="images/Vector-data-3d-5.png" alt="bus lines"></p>
<h2>Result</h2>
<p>Congratulations ! By reaching here, we know how to display a simple <code>FeatureGeometryLayer</code>
on a <code>PlanarView</code>, and change the appearance and positioning of this layer. Here is the final code:</p>
<pre class="prettyprint source lang-html"><code>&lt;!DOCTYPE html>
&lt;html>
    &lt;head>
        &lt;meta charset=&quot;UTF-8&quot;>
        &lt;title>Vector data in 3D&lt;/title>
        &lt;style>
            html { height: 100%; }
            body { margin: 0; overflow: hidden; height: 100%; }
            #viewerDiv { margin: auto; height: 100%; width: 100%; padding: 0; }
            canvas { display: block }
        &lt;/style>
     &lt;/head>
     &lt;body>
        &lt;div id=&quot;viewerDiv&quot;>&lt;/div>
        &lt;script src=&quot;js/itowns.js&quot;>&lt;/script>
        &lt;script type=&quot;text/javascript&quot;>

            // Retrieve the view container
            const viewerDiv = document.getElementById('viewerDiv');

            // Define the view geographic extent
            itowns.proj4.defs(
                'EPSG:3946',
                '+proj=lcc +lat_1=45.25 +lat_2=46.75 +lat_0=46 +lon_0=3 +x_0=1700000 +y_0=5200000 +ellps=GRS80 ' +
                '+towgs84=0,0,0,0,0,0,0 +units=m +no_defs',
            );
            const viewExtent = new itowns.Extent(
                'EPSG:3946',
                1837816.94334, 1847692.32501,
                5170036.4587, 5178412.82698,
            );

            // Define the camera initial placement
            const placement = {
                coord: new itowns.Coordinates('EPSG:3946', 1840839, 5172718, 0),
                tilt: 30,
                heading: 45,
                range: 1800,
            };

            // Create the planar view
            const view = new itowns.PlanarView(viewerDiv, viewExtent, {
                placement: placement,
            });

            // Define the source of the ortho-images
            const sourceOrtho = new itowns.WMSSource({
                url: 'https://download.data.grandlyon.com/wms/grandlyon',
                name: 'Ortho2009_vue_ensemble_16cm_CC46',
                format: 'image/jpeg',
                crs: 'EPSG:3946',
                extent: viewExtent,
            });
            // Create the ortho-images ColorLayer and add it to the view
            const layerOrtho = new itowns.ColorLayer('Ortho', { source: sourceOrtho });
            view.addLayer(layerOrtho);

            // Define the source of the dem data
            const sourceDEM = new itowns.WMSSource({
                url: 'https://download.data.grandlyon.com/wms/grandlyon',
                name: 'MNT2018_Altitude_2m',
                format: 'image/jpeg',
                crs: 'EPSG:3946',
                extent: viewExtent,
            });
            // Create the dem ElevationLayer and add it to the view
            const layerDEM = new itowns.ElevationLayer('DEM', {
                source: sourceDEM,
                useColorTextureElevation: true,
                colorTextureElevationMinZ: 144,
                colorTextureElevationMaxZ: 622,
            });
            view.addLayer(layerDEM);

            // Define the altitude of buildings
            function setBuildingsAltitude(properties) {
                return properties.z_min - properties.hauteur;
            }

            // Define the height of buildings
            function setBuildingsExtrusion(properties) {
                return properties.hauteur;
            }

            // Define the color of buildings
            function setBuildingsColor(properties) {
                return new itowns.THREE.Color(0xaaaaaa);
            }

            // Define the source of buildings data
            const buildingsSource = new itowns.WFSSource({
                url: 'http://wxs.ign.fr/3ht7xcw6f7nciopo16etuqp2/geoportail/wfs?',
                typeName: 'BDTOPO_BDD_WLD_WGS84G:bati_indifferencie',
                crs: 'EPSG:4326',
            });

            // Create a FeatureGeometryLayer to display buildings data and add it to the view
            const buildingsLayer = new itowns.FeatureGeometryLayer('Buildings', {
                source: buildingsSource,
                zoom: { min: 4 },
                style: new itowns.Style({
                    fill: {
                        color: setBuildingsColor,
                        base_altitude: setBuildingsAltitude,
                        extrusion_height: setBuildingsExtrusion,
                    },
                }),
            });
            view.addLayer(buildingsLayer);

            // Define the altitude of bus lines
            function setBusAltitude(properties, contour) {
                if (contour) {
                    return (itowns.DEMUtils.getElevationValueAt(view.tileLayer, contour) || 0);
                } else {
                    return 0;
                }
            }

            // Define the source of bus lines data
            const busSource = new itowns.WFSSource({
                url: 'https://download.data.grandlyon.com/wfs/rdata?',
                typeName: 'tcl_sytral.tcllignebus',
                format: 'geojson',
                crs: 'EPSG:3946',
                version: '2.0.0',
            });

            // Create a FeatureGeometryLayer to support bus lines data and add it to the view
            const busLayer = new itowns.FeatureGeometryLayer('Bus', {
                source: busSource,
                zoom: { min: 4 },
                style: new itowns.Style({
                    stroke: {
                        width: 5,
                        base_altitude: setBusAltitude,
                    },
                }),
            })
            view.addLayer(busLayer);
            
        &lt;/script>
     &lt;/body>
&lt;/html>
</code></pre>
</article>

</section>

<script> prettyPrint(); </script>
<script src="../scripts/linenumber.js"> </script>
</body>
</html>